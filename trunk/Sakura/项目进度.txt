

项目:
项目描述:毕业设计。用于工业软件的网络整体监控。
开始时间:2009年3月
开发系统:WindowsXP+SP3
多环境测试:无计划。



[界面与内核]

	kernel:
	1.(已实现)为后续VB开发者提供了一个ocx控件:Channel.ocx
	2.提供一个DLL,为非VB开发者提供相应的应用方案。
	3.(开发中)Server/Client程序。此程序封装了基于UDP的通信协议，和与Channel.OCX之间的交互。
	
	Shell:
	1.(已实现)所有使用了Channel.ocx的程序的设置工具.
	2.针对工厂这种特定的环境，为现有的kernel提供一套Shell，以简捷明了的针对不同工厂搭建不同的监控环境，并直观地显示数据流通情况。现有设置工具将被整合进这套Shell里。




{当前进度说明}

	后续VB开发者若想使用这套监控系统，只需加载有Channel.ocx，简单地用其提供的一个Sub跟一个Event，就可以实现整个监控过程。
	
	Channel.ocx说明:
	实现了一个函数(方法):
		Sub SendDataToChannel(data as string)
		此方法将参数data的内容，通过Server/Client程序发送至网络。
	实现了一个事件:
		Event DataArrival(data as string)
		当Server/Client收到相应的数据时，会通知Channel.OCX触发这个事件，收到的数据存于data中。


	



	


[网络]
	
	程序用UDP协议。 
	在UDP的基础上构造了一套通信协议。此协议如下:
	
	
{当前进度}
	
	Server/Client:
	
	用到三个Winsock控件，分别绑定三个端口,作用:
	
	wskBroadCast	广播数据	LP:7000	RP:7000
	wskControl		协议控制	LP:7500	RP:7500
	wskXChange		数据交换	LP:7600	RP:7600
	
	
	流程描述:
		
	广播:
		Server/Client运行后，wskBroadCast每隔一定时间向网络7000端口发送一个广播数据包，用以通知网络此处有Server/Client运行。
	控制:
		每次收到7000端口的广播后，取得远程端的IP，向其7500端口发送一个TOUCH包，若收到回应，则请求远程端的信息。此包还用于测试网速与保持在线。
		若一定时间内未收到来自某连接的TOUCH包，则视为此连接超时。
		若进行连接，则连接端向远程端请求一个64位的TOKEN，这个TOKEN用于wskXChange进行数据传输。
	 数据:
		每次构造一个含有TOKEN的数据包进行通信，收到数据包后，通过TOKEN检验是否是合法数据包。
		
	
	协议包构造:
		
		目前协议包用的明文方式传送.
		
		包		包序号	Socket		数据包构造			说明
		TOUCH			wskControl	"AREYOUASERVER"		固定包
		HANDSHAKE	1	wskControl	"YESIAMASERVER"		固定包
					2	wskControl	"GIVEMEYOURID."		固定包
					3	wskControl	"ID{COMPUTERNAME}"	从第三字节开始设置计算机标识
		TOKEN			wskControl	"TOKENXXXXXXX"		从第五字节开始连续64字节为令牌
		DATA			wskXChange						前64位为TOKEN,第65位开始为数据
		
		

					
{缺陷分析和解决方案}
	1. 数据明文传送。这在数据安全性上是一大缺陷。但是由于此系统是用于工厂内部网络间的数据传递。并不是很紧迫的问题。
	同样，网络监听、截获、伪造数据包也不在当前考虑范围内。
	2.数据丢失问题。
	这个问题主要会发生在wskXChange上。对于UDP这种无连接套接字而言，发送方只负责发送而不考虑数据是否顺利发送，接收方收到数据而不作出收到响应。在网络繁忙的情况下很容易造成数据的丢失。
	简单的解决这个问题，接收方收到数据后要向发送方回传一个收到标识。确定数据已经收到。而发送方如果未收到回复数据包，则视为网络不通，而重发同一数据包。
	而这样会造成一个问题，当网络足够慢，以致回复包的传递时间大于发送方的超时时间时，接收方会收到两个相同的数据包。而从实时监控系统的实时性上考虑，此数据包不可被丢弃。
	那么，标识数据包就成为必然。如何标识一个数据包，这里有三个方案.
		a.为每个数据包分配一个唯一标识GUID.只有当回复数据包里包含了复制到的相同的GUID时才会视为数据到达，而接收端在收到两个相同的GUID标识的数据包时则视为重复而抛弃。
		用GUID而不用随机数的原因是由于随机数的连续可重复性跟GUID的不可重复性，若连续两个相同内容的数据包被分配到了相同的随机数，则后来的数据包必然会被抛弃掉。如此无法实现实时监控的准确性。
		b.为每个连接分配一个包序列。这个连接有数据传送时将当前包的序号封装在内，此序号只可递增不可递减。发送方每构造一个新的数据包时都将包序号加1。若达到最大序号则重新与接收方进行连接。这实际上是TCP方式。
		c.在每个数据包上加上构造包时的时间戳。这样只要不在1ms内有连续的一个以上的相同的数据包发送，此方案有效。
	
	另一个数据丢失的问题是包长度检测。现有的没有包长度检测的情形下，数据包的后半段数据可能会丢失。
	这样，在数据包的构造上要加一段包长度信息，用来标识整个数据包的长度。当长度不够时，此包抛弃。
	抛弃数据包后若等待发送方超时重发，效率是很低下的。那么这里要构造一个含有重发请求的数据包。而因为收到包的不完全，所以重发包应该包含了在这之前收到的最后一个包的包序号。
	
	
	<VB实现>
	需要一个数据队列。每次发送数据包时，将所有要发送的包放入这个队列中。收到回复消息后从队列中删除相应的数据包。
	既然VB不支持多线程，那么需要一个Timer，此Timer遍历整个队历关发送其中的所有数据包。数据包的初始超时剩余时间置零，这个Timer的过程检测到有超时的数据包时将重新发送,并将超时剩余标置重置，超时次数加1。对于未超时的数据包将其超时标志递减。 当队列中存在同一IP的多个数据包时，只对第一个进行重发。当某个数据包超时次数超过某额定值时，判断为此IP网络不通或离线。
	
	队列中数据格式:
	Type PACKET
		RemoteIP As String		'目的IP
		DataIndex As Integer	'包序号
		TimeOut As Integer		'超时剩余时间
		toCount As Integer		'超时次数
		Data As String			'数据包
	End Type














